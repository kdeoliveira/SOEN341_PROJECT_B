halt        0x00 Stop virtual machine 
pop         0x01 Remove top of stack  
dup         0x02 Duplicate top of stack 
exit        0x03 Return from function with parameters
ret         0x04 Return from function
not         0x0C Bitwise oneâ€™s complement
and         0x0D Bitwise AND
or          0x0E Bitwise OR
xor         0x0F Bitwise XOR
neg         0x10 Negate
inc         0x11 Increment
dec         0x12 Decrement
add         0x13 Addition
sub         0x14 Subtraction
mul         0x15 Multiplication
div         0x16 Division
rem         0x17 Remainder, modulo
shl         0x18 Shift left
shr         0x19 Shift right
teq         0x1A Test for equal
tne         0x1B Test for not equal
tlt         0x1C Test for less than
tgt         0x1D Test for greater than
tle         0x1E Test for less or equal
tge         0x1F Test for greater or equal
br.i5       0x30 Branch always
brf.15      0x50 Branch if v != 1
enter.u5    0x70 Set up frame
ldc.i3      0x90 Load constant
addv.u3     0x98 Add TOS to variable
ldv.u3      0xA0 Load variable
stv.u3      0xA8 Store variable
addv.u8     0xB0 Add TOS to variable
ldv.u8      0xB1 Load variable
stv.u8      0xB2 Store variable
incv.u8     0xB3 Increment variable
decv.u8     0xB4 Decrement variable
enter.u8    0xBF Set up frame on function entry
lda.i16     0xD5 Load address
ldc.i8      0xD9 Load an 8-bit constant
ldc.i16     0xDA Load a 16-bit constant
ldc.i32     0xDB Load a 32-bit constant
br.i8       0xE0 Branch relative always
br.i16      0xE1 Branch relative always
brf.i8      0xE3 Branch relative if false
call.i16    0xE7 Call relative
trap        0xFF Trap to vector